#+setupfile: info/index-bigblow-header.setup
#+include: info/common-header.org
#+AUTHOR: 鈴木正幸，非常勤講師
#+OPTIONS: tex:t 
#+property: header-args:R :session *bioR* :results output :exports both

#+begin_src R :tangle R-intro/code/0403.R
#+end_src

* 初心者用 R 言語講座 の演習ノート
  [[http://chianti.ucsd.edu/~rsaito/ENTRY1/WEB_RS3/PDF/JPN/Texts/R_Stats2.pdf][初心者用 - R_Stats2.pdf]]

**  4. 簡単なベクトル演算
 既に説明したように、c の直後に括弧の中に入った数字を並べることでベク
 トルを表現することができます。
 (x <- c(2,4,6,8,10)) # 
 length(x) # ベクトルの次元数、すなわちベクトル中の数値の個数
 x[3] # 3 番目の数値を抽出する
 x[c(2,4)] # 2番目と 4 番目の数値を抽出
 x[2:4] # 2 番目から 4 番目までの数値を抽出
 # ベクトルの比較演算 
 x > 5 # ベクトルの各要素が 5 より大きいかの判定
 より大きいか、大きくないかを判定した結果が TRUE, FALSE のベクトル(略
 して T, F)として返ってきます。>1+2 [1] 3 > 3

   > x <- c(2,4,6,8,10) >x
 [1] 2 4 6 8 10 >x>5
 [1] FALSE FALSE TRUE TRUE TRUE >
  which を使うと、何番目が T なのかが返ってきます。返ってきた T, F のベクトルを使っ てさらに which(c(F, F, T, T, T))とするとベクトル(3,4,5)が返ってきますが、一気に which(x > 5)としても同じ答えになります。
 この T, F のベクトルを使って、T の部分だけを抽出することが可能です。 x[ c(F, F, T, T, T)]
 以上をまとめて、x > 5 の要素だけを抽出するには、
 x[ x > 5 ]
 とすることができます。 実は数値だけでなく、文字列もベクトルのように扱うことができて、
 x <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")
 とした後、x[2]とすれば 2 番目の文字列”Monday”が取り出されます。文字列のベクトルに 対しても様々な操作が可能で例えば、
 grep(“sd”, x)
 は x の中で”sd”という部分文字列が含まれているのは何番目の要素かをベクトルで返しま す。従って以下のようにすると、”sd”が含まれている文字列を抽出することができます。
 ベクトルの各要素には names を使って名前を付けることができます。例えば、 x <- c(2, 4, 6)
 names(x) <- c("First", "Second", "Third")
   > x <- c(2,4,6,8,10)
 > which(x > 5)
 [1] 3 4 5
 >
            > x <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday") > x[ grep("sd", x) ]
 [1] "Tuesday" "Wednesday" "Thursday"
 >
    4

 とすると、x の names という属性に(“First”, “Second”, “Third”)が付けられ、 x[[ “Second” ]]
 で 2 番目の値が抽出されます。
 さらに数値データのみで構成されるベクトルに対しては様々な統計関数が定義されてい ます。例えば、
 sum(x)
 でベクトル x の合計、
 mean(x)
 で x の平均が求められます。さらに T または F から構成されるベクトル x については sum(x) で T の数を数えるので、
 x <- c(2,4,6,8,10)
 sum(x > 5)
 でベクトル x の要素の中で 5 を超えるものがいくつあるか、すなわち 3 を返します。
 課題 4-1: ベクトル(3, 1, 4, 1, 5, 9, 2, 6, 5)の中で 5 より大きい要素からなるベクトルを作成 しましょう。
 課題 4-2: ベクトル(1,2,3,4,5,6,7,8,9,10,11,12)に(“Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec”)という名前を付け、”Mar”という文字列を使って 3 番目の要素を取り出してみましょう。
**  5. 簡単な行列の作成と演算
 ベクトルを集めると、rbind を使って行列を作成することが可能です。例えば 1 行目が
 1 2 3 (1,2,3)、2行目が(4,5,6)の行列x=  を作るには、
         456
  
  x <- rbind(c(1,2,3), c(4,5,6))
 とします。その後に x と入力すると、作成した行列が表示されるのが分かります。
 これは、
 x <- matrix(c(1, 4, 2, 5, 3, 6), nrow=2, ncol=3)
  
   > x <- rbind(c(1,2,3), c(4,5,6)) >x
 [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 >
    5

 または、
 x <- matrix(c(1, 2, 3, 4, 5, 6), nrow=2, ncol=3, byrow=T)
 としても作成可能です。上記は(1, 2, 3, 4, 5, 6)を使って 2 行 3 列の行列を作成する(nrow=2, ncol=3)、その際行から埋めてゆく(byrow=T)、ということを表しています。
 作成した行列 x に対しては様々な演算が可能です。nrow(x), ncol(x)はそれぞれ x の行数 と列数を表します。x + 1 は行列の各要素に 1 を足した答えを返し、x * 2 は各要素を 2 倍 にした答えを返します。行列同士の演算も可能で、y <- rbind(c(2, 4, 6), c(8, 10, 12))とした 後、x + y とすると、行列 x と y の対応する各要素同士を足し合わせた行列が返ってきます。 x * y なら各要素同士を掛け合わせた行列が返ってきます2。
 行列からは任意の行や列を簡単に取り出すことができます。例えば、2行目を取り出し たい場合、
 とします。また、2 列目を取り出したい場合は、
 とします。
 t(x)とすると、行列 x が転置されます(行と列が入れ替わる)。
     > x[2,]
 [1] 4 5 6
 >
    > x[,2] [1] 2 5
    > t(x)
     [,1] [,2]
 [1,] 1 4 [2,] 2 5 [3,] 3 6
  >
  行列 x の各行の平均は以下のように求めることができます3。
 行列 x の各列の平均は以下のように求めることができます。 > apply(x, 2, mean)
 2 行列の積は%*%で計算する。
 3 apply の中の 1 は一次元目の各項番の平均、すなわち各行の平均を計算することを意味す る。同様にして、2 は二次元目の各項番の平均、すなわち各列の値の平均を計算すること を意味する。
  > apply(x, 1, mean)
 [1] 2 5
   6

  [1] 2.5 3.5 4.5
 行列は 2 次元の数値の羅列ですが、R では array(ベクトル、各次元の要素の個数)を使っ てさらに n 次元に拡張された配列を扱うことができます。
 x <- array(1:24, c(3,4,2))
 は 3×4×2 の大きさの3次元配列を作成し、一番目の次元目の値から順番に埋めてゆきま す。
     > x <- array(1:24, c(3,4,2))
 >x
 , , 1 # 3次元目の1番目の3×4配列
 [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12
 , , 2 # 3次元目の2番目の3×4配列
 [,1] [,2] [,3] [,4] [1,] 13 16 19 22 [2,] 14 17 20 23 [3,] 15 18 21 24
 >
  1 3 5 1 2 3
 課題5-1:   を計算しましょう。
 7 9 11 2 4 6
    
 課題5-2: 上記結果に対して行、列それぞれの平均を求めましょう。 

**  6. 簡単なリストの作成 リストは様々な型のデータをひとまとめにして管理できるデータ型です。
  x <- list("Oh", "Nomura", "Kadota")
 は”Oh”、”Nomura”、”Kadota”を要素とするリストを作成します。これらは全て文字列です が、ベクトルを織り交ぜることもできます。
 x <- list("Oh", "Nomura", "Kadota", c(868, 657, 567))
    7

 で最後にベクトル(1, 2, 3)が加わっています。ここから2番目の要素を取り出すためには、
 x[[2]]
 とします。各々の要素に名前を付けることも可能です。
 x <- list(First="Oh", Second="Nomura", Third="Kadota", Home_Runs=c(868, 657, 567))
 として、各々の要素に First, Second, Third, Home_Runs という名前が付いていることを確 認しましょう。
       >x
  $First
 [1] "Oh"
 $Second
 [1] "Nomura"
 $Third
 [1] "Kadota"
 $Home_Runs
 [1] 868 657 567
 >
  名前を使って個々の要素を取り出すためには(例えば2つ目の要素を取り出すには)、 x[["Second"]]
 または
 x$Second
 とします。
 課題 6-1: 名前が Yamagata のベクトル(“Tsuruoka”, “Sakata”, “Yonezawa”)と名前が Niigata のベクトル(“Yuzawa”, “Niitsu”, “Shibata”)を要素にしたようなリストを作成し、そ の中味を表示してみましょう。
      8

** 7. 簡単なデータフレームの作成
 R にはデータフレームと呼ばれる型が存在します。これもリストの一種で、行列と同じ二
 次元配列です。データフレームの各々の行は1つのサンプルに対する観測値、各列はサン プルに対する1つの項目とみなすことができます。これを使うと、表を簡単に表現するこ とができます。以下の表は日本プロ野球の5人の元選手の名前、在籍チーム名、通算打数、 安打数、本塁打数を表したものです。
 Home_Runs 2901 657 3085 504 2543 504 2786 868 2566 567
 row.names = c("Nomura", "Harimoto", "Kinugasa", "Oh", "Kadota"), Team = c("Hawks", "Flyers", "Carps", "Giants", "Hawks"),
 At_Bat = c(10472, 9666, 9404, 9250, 8868),
 Hits = c(2901, 3085, 2543, 2786, 2566),
 Home_Runs = c(657, 504, 504, 868, 567))
 データフレームを作り出す関数 data.frame は data.frame(row.names = 列のラベルのベク トル、列名 1 = ベクトル 1、列名 2 = ベクトル 2, ···)の形式で使うことができます。x の中 味は以下のようになっていることが分かります。
      Team At_Bat Hits Hawks 10472 Flyers 9666 Carps 9404 Giants 9250 Hawks 8868
      Nomura
 Harimoto
 Kinugasa
 Oh
 Kadota これをデータフレームを使って表すと以下のようになります。 x <- data.frame(
                              >x
 Nomura Hawks 10472 2901 657
 Team At_Bat Hits Home_Runs
  Harimoto Flyers 9666 3085 504 Kinugasa Carps 9404 2543 504 Oh Giants 9250 2786 868 Kadota Hawks 8868 2566 567 >
  通常のリストと同様、列名を使って対応するベクトルを抽出することができます。
   > x$Hits
 [1] 2901 3085 2543 2786 2566
 >
  9

 データフレームからは、任意の部分をさらにデータフレームとして抽出することができ ます。例えば 1、5 行目と 2、3、4 列目を抽出する場合、
 x[ c(1,5), c(2,3,4) ]
 とします4。
 データフレームに対してさらに様々な処理が可能です。まずは上記で定義された x にど のような属性があるのか、attributes で調べてみましょう。
     > attributes(x)
  $names
 [1] "Team" "At_Bat" "Hits" "Home_Runs"
 $row.names
 [1] "Nomura" "Harimoto" "Kinugasa" "Oh" "Kadota"
 $class
 [1] "data.frame"
 >
  属性として、names, row.names, class が出てきました。names(x)、row.names(x)、class(x) と入力してみましょう。それぞれ列名、行名、x の型が出てくるでしょう。
 課題 7-1: 下の表は G8 加盟国の国力の一部です。これをデータフレームとして変数にしま しょう5。
     Area
 USA 9.4
 England 0.2 Italy 0.3 Canada 10.0 Germany 0.3 Japan 0.3 France 0.5 Russia 17.1
 Population
 GDP
     315
  62
  60
  34
  82
 127
  62
 141
 14 3 2 2 4 5 3 2
                                  4 x[c("Nomura", "Kadota"),c("At_Bat", "Hits", "Home_Runs")]でも同様に 動作する。
 5 要素が全て数値なので、行列として扱うこともできる。データフレームにしてしまった 変数 x に対しては行列演算ができないことがあるので、その場合は as.matrix(x)で行列に 変換する。
 10

 課題 7-2: 上記で作成したデータフレームより G8 加盟国の国土面積、人口、GDP の平均を それぞれ求めましょう。


**  8. ファイルからの読み込み
   これまでは数値データを全て入力していました。しかし、数値データはファイルで用意
 されることも多いでしょう。そこでファイルから数値データを読み込む方法を紹介します。 まず、以下のような数値データが書かれたファイルを用意しましょう。仮にこのファイル 名を testdata.txt、ディレクトリの位置を/Users/saito/TMP/とします。
 14
 14 21 35 6
 まず setwd によって作業ディレクトリを/Users/saito/TMP にします。 setwd("/Users/saito/TMP")
 次に scan コマンドを使って、データを変数 x に読み込みます。
 x にファイルの数値がベクトルとして読み込まれているのが分かります。
 R では表の読み込みを行う関数 read.table が用意されています。以下のようなタブ区切 りのファイル batters.txt があったとします。
       > x <- scan("testdata.txt") Read 5 items
 >x
 [1]14142135 6
 >
   Team Nomura Hawks
 Harimoto Kinugasa
 Oh Giants Kadota Hawks
 At_Bat Hits 10472 2901 Flyers 9666 Carps 9404 9250 2786 8868 2566
 Home_Runs 657
 3085 504 2543 504 868
 567
  read.table を使うとこれをデータフレームとして読み込むことができます6。
 6 read.table には様々なオプションがある。引数に quote=””を指定すると、表中の引用符 等に対して特別な扱いをしなくなる。check.names=F で列ラベル名の自動変換が抑制され る。comment.char=””でコメント記号(“#”)を無効にできる。
  11

   > x <- read.table("batters.txt", header = T, sep = "¥t", row.names = 1)
 >x
 Team At_Bat Hits Home_Runs Nomura Hawks 10472 2901 657
 Harimoto Flyers 9666 3085 504 Kinugasa Carps 9404 2543 504 Oh Giants 9250 2786 868
  Kadota Hawks 8868 2566 567 >
  関数の引数の最初で”batters.txt”と読み込むファイル名を指定し、次に Team, At_Bat など のヘッダーがあることを header = T で示します。そして sep = “¥t”でタブ区切りであるこ とを示し7、最後に行の名前が1列分あることを row.names = 1 で指定します。変数 x はデ ータフレームとなるので、x$Hits などで安打数を得ることができます。
 課題 8: 課題 7-1 の表をタブ区切りファイルとして保存し、データフレームとして読み込ん でみましょう。

**  9. ファイルへの書き出し
 統計処理の結果を一時的に画面で確認するだけでなく、ファイルに書き出して後で表計
 算ソフトや他のプログラムで読み込みたいというケースがあるでしょう。ファイル出力を する上で一番簡単なのが write 関数でしょう。これを使うと、変数に格納された数値をファ イルに書き出すことができます。例えば、
 x <- c(10, 12, 15, 19, 21, 34)
 で変数 x にベクトルを代入した後、
 write(x, "outfile1.txt", ncolumns = 1)
 とすると、x の内容が”outfile1.txt”というファイルに書き込まれます。ncolumns = 1 は数 値を 1 列で出力することを指定しています。
 outfile1.txt の中味:
 10
 12 15 19
 7 処理系によっては、\は\ (バックスラッシュ)になる。Macintosh では、option キーを押 しながら、\キーを押す。
	12

  21 34
 write 関数を使うとさらに以下のように行列データもファイルに書き出すことが可能で す。
    > x <- matrix(c(1,2,3,4,5,6), nrow=2, ncol=3, byrow=T) >x
  [,1] [,2] [,3]
 [1,] 1 2 3
 [2,] 4 5 6
 > write(t(x), "outfile2.txt", ncolumns=ncol(x), sep="¥t") >
  t(x)で行列 x を転置しないと、出力されるファイル中の行列が転置されたものになってしま うので、注意が必要です。ncolumns=ncol(x)で出力される列数を行列 x の列数に揃え、sep = “¥t”でタブ区切りファイルにすることを指定しています。
 outfile2.txt の中味:
 123 456
 データフレームをファイルに出力する関数として、write.table が用意されています。これ はデータフレームの内容をファイルに書き出します。
     > x <- data.frame(
 row.names = c("Nomura", "Harimoto", "Kinugasa", "Oh", "Kadota"), Team = c("Hawks", "Flyers", "Carps", "Giants", "Hawks"),
 At_Bat = c(10472, 9666, 9404, 9250, 8868),
  Hits = c(2901, 3085, 2543, 2786, 2566),
 Home_Runs = c(657, 504, 504, 868, 567)) > x[,c(3,4)]
 Hits Home_Runs Nomura 2901 657
 Harimoto 3085 504
 Kinugasa 2543 504
 Oh 2786 868
 Kadota 2566 567
 > write.table(x[,c(3,4)], "outfile3.txt", sep="¥t", row.names=T, col.names=NA)
  13

   >
 row.names=T, col.names=NA でそれぞれ行名、列名(先頭に空白を挿入)を入れます。 outfile3 の中味:
 "" "Hits" "Home_Runs"
 "Nomura" 2901 657
 "Harimoto" 3085 504 "Kinugasa" 2543 504 "Oh" 2786 868 "Kadota" 2566 567
 ちなみに quote=F を指定すると、二重引用符を除いた出力になります。
 課題 9: 上記データフレームで、各バッターに対して打率、すなわち Hits / At_Bat を計算
 し、その結果を”outfile4.txt”に格納しましょう。
 10. プログラムの読み込み これまでは変数への代入操作などを全て対話的に行っていました。しかし決まった長い
 手続きを何度も入力するのは面倒です。そこで一連の手続きをファイルにしておいて、そ れを必要なときに実行することが可能です。例えば、以下のような操作を記述したファイ ルを用意します。ファイル名を substtest.R とします。
 x <- c(1,2,3,4,5)
 y <- c(2,4,6,8,10)
 z <- x + y
 これを以下のように source(“substtest.R”)とすると、substtest.R 中に記述された手続きを 実行することができます。結果として x, y, z それぞれに値が代入されます。
	> source("substtest.R")
  >x [1] >y [1] >z [1] >
 1 2 3 4 5
 2 4 6 8 10 3 6 91215
  課題 10: 課題 8 の手続きを dframetest.R というファイルに書き込み、source を使ってその 手続きを実行してみましょう。
 14


**  11. 関数の定義
      関数は数学的にはある入力に対応した出力を返すものです。コンピュータプログラミン
 グでは、まとまった処理の単位を表します8。例えば今、二つの数を足して 2 で割る関数 f を考えます。これは数学では f(x, y) = (x + y) / 2 などと記述できますが、R では以下のよう に function を使って以下のように記述します。
 f <- function(x, y){
    return ((x + y) / 2)
 }
 これによって x と y を入力(引数)とする関数 f が定義されます。そして出力(返り値)が(x + y) / 2 となるのです。その後、
 f(10, 20)
 とすれば、x に 10、y に 20 が代入され、15 という答えが返ってくるはずです9。このよう に return は最終的な返り値を決めます。
       関数のより一般的な定義の仕方は、
 関数名 <- function(引数 1, 引数 2, ···, ...){ 引数を使った様々な処理 return(返り値)
 } です10。
 課題 11: f(x, a, b, c) = ax2 + bx + c を R の関数として実装しましょう。f(4, 3, 2, 1)はいくつ になりますか。

**  12. グラフの作成
 R では簡単にグラフを作成する関数が用意されています。plot 関数は二次元プロットを
 作成することができます。例えば以下のように x 座標と y 座標の値をそれぞれベクトルと して与えると、(1,2), (3,4), (5,9), (7,7), (9,8)の点にプロットを作成できます。
 x <- c(1,3,5,7,9)
 y <- c(2,4,9,7,8)
 plot(x, y, xlab="X Value", ylab="Y Value")
 8 サブルーチンという呼び方がより正確。
 9 f(x=10, y=20)のようにどの引数のどの値を渡すかを明示してもよい。 10 追加引数...の中味は list(...)でリストとして閲覧することが可能。
	15

 xlab, ylabでそれぞれx軸、y軸のラベルを指定しています。
    2468 X Value
 作成されたプロット
 barplot を使うと、棒グラフを作成することができます。以下の例では、各棒の高さに対 応させるベクトルおよびそのラベルを変数 x に与え、barplot(x)を呼び出しています。
 x <- c(1,2,3,2,10,1)
 names(x) <- c("A", "B", "C", "D", "E", "F")
 barplot(x)
      A B C D E F
 作成された棒グラフ
 hist はベクトルで与えられた数値群のヒストグラムを作成する関数です。
 x <- c(3.2, 1.2, 4.2, 2.3, 3.4, 5.9, 5.2, 5.3, 4.1, 5.2, 3.2, 1.4) hist(x, xlab = "Test Value", main = "Test Histogram")
 main によってヒストグラムのタイトルを指定しています。 16
   0 2 4 6 8 10
 Y Value 23456789

 Test Histogram
	123456
 Test Value
 作成されたヒストグラム
 boxplot は複数のベクトル中に含まれる値の分布を表す箱ひげ図を作成します。
 x1 <- c(11,12,11,10,11,11,12,13,15,12,11,10,12,13)
 x2 <- c(20,21,27,9,12,23,23,12,11,9,21,15,7,12,12,9,23,15) boxplot(x1, x2, names=c("Data 1", "Data 2"))
    中央値
 外れ値
 外れ値を除く上位25%
 この範囲に50%の データが分布する
 外れ値を除く下位25%
     作成された箱ひげ図
 課題 12: 課題 7-1 で与えられた表に関して、国土面積と人口の関係をプロットしてみまし ょう。
 17
 Frequency
 01234

**  13. 基本的なプログラミングの構文
 R には他のプログラミングにも存在するような基本的なプログラミングの構文も用意さ
 れています。ここではそれらについてかいつまんで簡単に説明します。
 13.1 if 文
 if 文は与えられた条件11が成立するときのみ、与えられた手続きを実行する構文です。例
 えば x > 0 のときに y を 1 にする、それ以外は y を 0 にするという手続きは if (x > 0){
 y <- 1 } else {
 y <- 0 }
 とします。x = -5 にした後上記を実行し、y の値を調べてみましょう。次に x = 3 にした後 上記を実行し、y の値を調べましょう。
 if 文のより一般的な形式は以下の通りです。 if (条件 1){
 条件 1 が成立したときの手続き
 } else if (条件 2){
 条件 1 が不成立、条件 2 が成立したときの手続き
 } else if(条件 3){
 条件 2 までが不成立、条件 3 が成立したときの手続き
 } else if ...
 :
 } else {
  上記どの条件も成立しなかったときの手続き
 }
 課題 13-1: 入力が 0 のときに 1、それ以外では 0 を返す関数 d を定義しましょう。
 13.2 while 文
 while 文は与えられた条件が成立している間、与えられた手続きを繰り返す構文です。
 while 文の形式は
 11 条件文には&(論理積)や|(論理和)などの論理演算子が使える。
    18

 while(条件){ 条件が成立しているとき、実行する手続き
 }
 です12。例えば x <- 1 とした後、while (x <= 3){ print(x); x <- x + 1 }とすれば、1 から 3 ま
 でが出力されます。
 プログラムとしてファイルに記述するときは、次のように一行一文にした方が見やすい でしょう。
   x <- 1
   while (x <= 3){
 print(x)
 x <- x + 1 }
 ・ 最初に while 文に入ったとき、x は 1 なので、while 文の中の手続きである print(x)(x の値を表示する)が実行され、1 が表示されるとともに x <- x + 1 (x の値を 1 つ増やす)が 実行されます。while 文の最後で x の値は 2 になっています。
 ・ 次の while 文の条件判定において、x は 2 で 3 以下なので、while 文の中の手続きであ る print(x)が実行され、2 が表示されるとともに x <- x + 1 (x の値を 1 つ増やす)が実行さ れます。while 文の最後で x の値は 3 になっています。
 ・ その次の while 文の条件判定において、x は 3 で 3 以下なので、while 文の中の手続き である print(x)が実行され、今回は 3 が表示されるとともに x <- x + 1 (x の値を 1 つ増や
 12 while 文の次の繰り返しを強制的に行う next、while 文から強制的に抜ける break 文な ども用意されている。
   > x <- 1
  > while (x <= 3){ print(x); x <- x + 1 } [1] 1
 [1] 2
 [1] 3
 >
       19

 す)が実行されます。while 文の最後で x の値は 4 になっています。
 ・ その次の while 文の条件判定で x は 4 で 3 以下ではないので、条件に合わず、while 文
 から抜けます。
 課題 13-2: while 文を使って、1,3,5,7,9,11 を1行ずつ表示しましょう。
 13.3 for 文
 for 文も while 文と同じ繰り返しですが、for 文では与えられた要素群の中の要素1つ1
 つを変数に1回ずつ代入しながら繰り返し処理を行います。その形式は、
 for(変数 in 要素群){ 手続き
 }
 です。例えば、for (i in c(1,3,5)){ print(i) }で、1,3,5 が手続き中で使われている変数 i に毎
 回代入され、それが出力されます。for (i in 1:5)){ print(i) }なら、1 から 5 までが変数 i に代
 入され、それが出力されるでしょう。また以下の例は、1 から 5 までの二乗をベクトルにし ます13。
 x <- NULL
 for (i in 1:5){
    x <- append(x, i**2)
 }
 ・ x <- NULL で空のベクトルを x に代入します。NULL は空を意味します。
 ・ for 文で i に 1 から 5 までが順次代入され、代入の度に for 文の中が実行されます。
 ・ for 文の中で i の二乗(i**2)がベクトル x に追加されます。append(x, i)はベクトル x に i
 を追加する関数です14。
 課題 13-3: 課題 12-2 を for 文を使って書き直しましょう。
 13 実は for 文を使わなくても、x <- (1:5)**2 で同じことができる。
 14 x <- c(x, i**2)でも良い。c はベクトルの連結にも使うことができる。
       20

**  14. その他のコマンドや関数
 R でよく使う関数をいくつか挙げておきましょう。

***  14.1 使い方
  ・ help(関数)で関数の詳しい使い方が表示されます。

***   14.2 変数と属性
  ・ ls()または objects()で現在定義されている変数が表示されます。
  ・ class(変数)または mode(変数)でオブジェクトの型(例えば変数が数値なのか、文字なの
  か、リストなのか、行列かなど)を知ることができます。
  ・ attributes(変数)で定義されている属性がリストで返ってきます。

***   14.3 apply 系関数
  ・ apply を使うと、行列の各行または各列に対して同じ処理を繰り返し、結果をベクトル
  で受け取ることができます(5. 簡単な行列の作成と演算参照)。
  ・ sapply を使うと、ベクトルの要素 1 つ 1 つを与えられた関数に入力し、出力結果を 1
  つ 1 つ含んだベクトルとして得ることができます
  func1_sub <- function(elm){ # スカラーelem に対する関数の定義 if(-1 <= elm & elm <= 1){ return (1) } else { return (0) }
  }
  func1 <- function(x){ # ベクトル x を入力とする関数
  return(sapply(x, func1_sub)) }

***   14.4 図の作成
  ・curve 関数で関数のグラフを作成できます。詳しくは help を参照して下さい。 例:
  curve(dnorm, -7, +7) # 正規分布の描画
  curve(cos(x)+cos(2*x), -2*pi, 2*pi, 1000) # 1000はプロット数 curve(func1, -3, 3) # 14.3apply系関数で定義した関数


